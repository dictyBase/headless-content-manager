// @generated by protoc-gen-es v1.6.0
// @generated from file dictybase/stock/stock.proto (package dictybase.stock, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message dictybase.stock.StockId
 */
export declare class StockId extends Message<StockId> {
  /**
   * Unique identifier for the stock
   *
   * @generated from field: string id = 1;
   */
  id: string;

  constructor(data?: PartialMessage<StockId>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StockId";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StockId;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StockId;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StockId;

  static equals(a: StockId | PlainMessage<StockId> | undefined, b: StockId | PlainMessage<StockId> | undefined): boolean;
}

/**
 * Definition for list of unique stock identifier
 *
 * @generated from message dictybase.stock.StockIdList
 */
export declare class StockIdList extends Message<StockIdList> {
  /**
   * @generated from field: repeated string id = 1;
   */
  id: string[];

  constructor(data?: PartialMessage<StockIdList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StockIdList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StockIdList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StockIdList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StockIdList;

  static equals(a: StockIdList | PlainMessage<StockIdList> | undefined, b: StockIdList | PlainMessage<StockIdList> | undefined): boolean;
}

/**
 * Definition of an individual strain
 *
 * @generated from message dictybase.stock.Strain
 */
export declare class Strain extends Message<Strain> {
  /**
   * @generated from field: dictybase.stock.Strain.Data data = 1;
   */
  data?: Strain_Data;

  constructor(data?: PartialMessage<Strain>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.Strain";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Strain;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Strain;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Strain;

  static equals(a: Strain | PlainMessage<Strain> | undefined, b: Strain | PlainMessage<Strain> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.Strain.Data
 */
export declare class Strain_Data extends Message<Strain_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Unique identifier for the strain
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.StrainAttributes attributes = 3;
   */
  attributes?: StrainAttributes;

  constructor(data?: PartialMessage<Strain_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.Strain.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Strain_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Strain_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Strain_Data;

  static equals(a: Strain_Data | PlainMessage<Strain_Data> | undefined, b: Strain_Data | PlainMessage<Strain_Data> | undefined): boolean;
}

/**
 * Definition of an individual plasmid
 *
 * @generated from message dictybase.stock.Plasmid
 */
export declare class Plasmid extends Message<Plasmid> {
  /**
   * @generated from field: dictybase.stock.Plasmid.Data data = 1;
   */
  data?: Plasmid_Data;

  constructor(data?: PartialMessage<Plasmid>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.Plasmid";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plasmid;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plasmid;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plasmid;

  static equals(a: Plasmid | PlainMessage<Plasmid> | undefined, b: Plasmid | PlainMessage<Plasmid> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.Plasmid.Data
 */
export declare class Plasmid_Data extends Message<Plasmid_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Unique identifier for the plasmid
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.PlasmidAttributes attributes = 3;
   */
  attributes?: PlasmidAttributes;

  constructor(data?: PartialMessage<Plasmid_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.Plasmid.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plasmid_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plasmid_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plasmid_Data;

  static equals(a: Plasmid_Data | PlainMessage<Plasmid_Data> | undefined, b: Plasmid_Data | PlainMessage<Plasmid_Data> | undefined): boolean;
}

/**
 * Definition of various strain attributes
 *
 * @generated from message dictybase.stock.StrainAttributes
 */
export declare class StrainAttributes extends Message<StrainAttributes> {
  /**
   * Timestamp for creation
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * Timestamp for update
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * User who created stock entry
   *
   * @generated from field: string created_by = 3;
   */
  createdBy: string;

  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 4;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 5;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 6;
   */
  editableSummary: string;

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 7;
   */
  depositor: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 8;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 9;
   */
  dbxrefs: string[];

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 10;
   */
  publications: string[];

  /**
   * Descriptor for the strain, a quick overview of its key genetic modifications
   *
   * @generated from field: string label = 11;
   */
  label: string;

  /**
   * Species of the strain
   *
   * @generated from field: string species = 12;
   */
  species: string;

  /**
   * Related plasmid for the strain
   *
   * @generated from field: string plasmid = 13;
   */
  plasmid: string;

  /**
   * Parent of the strain
   *
   * @generated from field: string parent = 14;
   */
  parent: string;

  /**
   * List of names for the strain
   *
   * @generated from field: repeated string names = 15;
   */
  names: string[];

  /**
   * dictybase specific strain property that will
   * map to dicty_strain_property ontology
   *
   * @generated from field: string dicty_strain_property = 16;
   */
  dictyStrainProperty: string;

  constructor(data?: PartialMessage<StrainAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainAttributes;

  static equals(a: StrainAttributes | PlainMessage<StrainAttributes> | undefined, b: StrainAttributes | PlainMessage<StrainAttributes> | undefined): boolean;
}

/**
 * Definition of various stock attributes
 *
 * @generated from message dictybase.stock.PlasmidAttributes
 */
export declare class PlasmidAttributes extends Message<PlasmidAttributes> {
  /**
   * Timestamp for creation
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * Timestamp for update
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * User who created stock entry
   *
   * @generated from field: string created_by = 3;
   */
  createdBy: string;

  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 4;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 5;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 6;
   */
  editableSummary: string;

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 7;
   */
  depositor: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 8;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 9;
   */
  dbxrefs: string[];

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 10;
   */
  publications: string[];

  /**
   * Image map for the plasmid
   *
   * @generated from field: string image_map = 11;
   */
  imageMap: string;

  /**
   * Sequence for the plasmid
   *
   * @generated from field: string sequence = 12;
   */
  sequence: string;

  /**
   * Unambiguous name for the plasmid
   *
   * @generated from field: string name = 13;
   */
  name: string;

  /**
   * dictybase specific plasmid property that will
   * map to dicty_plasmid_keyword ontology
   *
   * @generated from field: string dicty_plasmid_property = 14;
   */
  dictyPlasmidProperty: string;

  constructor(data?: PartialMessage<PlasmidAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.PlasmidAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlasmidAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlasmidAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlasmidAttributes;

  static equals(a: PlasmidAttributes | PlainMessage<PlasmidAttributes> | undefined, b: PlasmidAttributes | PlainMessage<PlasmidAttributes> | undefined): boolean;
}

/**
 * Definition for creating a new strain
 *
 * @generated from message dictybase.stock.NewStrain
 */
export declare class NewStrain extends Message<NewStrain> {
  /**
   * @generated from field: dictybase.stock.NewStrain.Data data = 1;
   */
  data?: NewStrain_Data;

  constructor(data?: PartialMessage<NewStrain>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.NewStrain";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewStrain;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewStrain;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewStrain;

  static equals(a: NewStrain | PlainMessage<NewStrain> | undefined, b: NewStrain | PlainMessage<NewStrain> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.NewStrain.Data
 */
export declare class NewStrain_Data extends Message<NewStrain_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: dictybase.stock.NewStrainAttributes attributes = 2;
   */
  attributes?: NewStrainAttributes;

  constructor(data?: PartialMessage<NewStrain_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.NewStrain.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewStrain_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewStrain_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewStrain_Data;

  static equals(a: NewStrain_Data | PlainMessage<NewStrain_Data> | undefined, b: NewStrain_Data | PlainMessage<NewStrain_Data> | undefined): boolean;
}

/**
 * Definition for creating a new plasmid
 *
 * @generated from message dictybase.stock.NewPlasmid
 */
export declare class NewPlasmid extends Message<NewPlasmid> {
  /**
   * @generated from field: dictybase.stock.NewPlasmid.Data data = 1;
   */
  data?: NewPlasmid_Data;

  constructor(data?: PartialMessage<NewPlasmid>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.NewPlasmid";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewPlasmid;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewPlasmid;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewPlasmid;

  static equals(a: NewPlasmid | PlainMessage<NewPlasmid> | undefined, b: NewPlasmid | PlainMessage<NewPlasmid> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.NewPlasmid.Data
 */
export declare class NewPlasmid_Data extends Message<NewPlasmid_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: dictybase.stock.NewPlasmidAttributes attributes = 2;
   */
  attributes?: NewPlasmidAttributes;

  constructor(data?: PartialMessage<NewPlasmid_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.NewPlasmid.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewPlasmid_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewPlasmid_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewPlasmid_Data;

  static equals(a: NewPlasmid_Data | PlainMessage<NewPlasmid_Data> | undefined, b: NewPlasmid_Data | PlainMessage<NewPlasmid_Data> | undefined): boolean;
}

/**
 * Defines attributes for creating a new strain
 *
 * @generated from message dictybase.stock.NewStrainAttributes
 */
export declare class NewStrainAttributes extends Message<NewStrainAttributes> {
  /**
   * User who created stock entry
   *
   * @generated from field: string created_by = 1;
   */
  createdBy: string;

  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 2;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 3;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 4;
   */
  editableSummary: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 5;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 6;
   */
  dbxrefs: string[];

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 7;
   */
  depositor: string;

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 8;
   */
  publications: string[];

  /**
   * Descriptor for the strain, a quick overview of its key genetic modifications
   *
   * @generated from field: string label = 9;
   */
  label: string;

  /**
   * Species of the strain
   *
   * @generated from field: string species = 10;
   */
  species: string;

  /**
   * Related plasmid for the strain
   *
   * @generated from field: string plasmid = 11;
   */
  plasmid: string;

  /**
   * Parent of the strain
   *
   * @generated from field: string parent = 12;
   */
  parent: string;

  /**
   * List of names for the strain
   *
   * @generated from field: repeated string names = 13;
   */
  names: string[];

  /**
   * dictybase specific strain property that will
   * map to dicty_strain_property ontology
   *
   * @generated from field: string dicty_strain_property = 14;
   */
  dictyStrainProperty: string;

  constructor(data?: PartialMessage<NewStrainAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.NewStrainAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewStrainAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewStrainAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewStrainAttributes;

  static equals(a: NewStrainAttributes | PlainMessage<NewStrainAttributes> | undefined, b: NewStrainAttributes | PlainMessage<NewStrainAttributes> | undefined): boolean;
}

/**
 * Defines attributes for creating a new plasmid
 *
 * @generated from message dictybase.stock.NewPlasmidAttributes
 */
export declare class NewPlasmidAttributes extends Message<NewPlasmidAttributes> {
  /**
   * User who created stock entry
   *
   * @generated from field: string created_by = 1;
   */
  createdBy: string;

  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 2;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 3;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 4;
   */
  editableSummary: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 5;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 6;
   */
  dbxrefs: string[];

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 7;
   */
  depositor: string;

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 8;
   */
  publications: string[];

  /**
   * Image map for the plasmid
   *
   * @generated from field: string image_map = 9;
   */
  imageMap: string;

  /**
   * Sequence for the plasmid
   *
   * @generated from field: string sequence = 10;
   */
  sequence: string;

  /**
   * Unambiguous name for the plasmid
   *
   * @generated from field: string name = 11;
   */
  name: string;

  /**
   * dictybase specific plasmid property that will
   * map to dicty_plasmid_keyword ontology
   *
   * @generated from field: string dicty_plasmid_property = 12;
   */
  dictyPlasmidProperty: string;

  constructor(data?: PartialMessage<NewPlasmidAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.NewPlasmidAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewPlasmidAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewPlasmidAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewPlasmidAttributes;

  static equals(a: NewPlasmidAttributes | PlainMessage<NewPlasmidAttributes> | undefined, b: NewPlasmidAttributes | PlainMessage<NewPlasmidAttributes> | undefined): boolean;
}

/**
 * Definition for loading an existing strain
 *
 * @generated from message dictybase.stock.ExistingStrain
 */
export declare class ExistingStrain extends Message<ExistingStrain> {
  /**
   * @generated from field: dictybase.stock.ExistingStrain.Data data = 1;
   */
  data?: ExistingStrain_Data;

  constructor(data?: PartialMessage<ExistingStrain>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.ExistingStrain";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExistingStrain;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExistingStrain;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExistingStrain;

  static equals(a: ExistingStrain | PlainMessage<ExistingStrain> | undefined, b: ExistingStrain | PlainMessage<ExistingStrain> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.ExistingStrain.Data
 */
export declare class ExistingStrain_Data extends Message<ExistingStrain_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Existing strain ID
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.ExistingStrainAttributes attributes = 3;
   */
  attributes?: ExistingStrainAttributes;

  constructor(data?: PartialMessage<ExistingStrain_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.ExistingStrain.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExistingStrain_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExistingStrain_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExistingStrain_Data;

  static equals(a: ExistingStrain_Data | PlainMessage<ExistingStrain_Data> | undefined, b: ExistingStrain_Data | PlainMessage<ExistingStrain_Data> | undefined): boolean;
}

/**
 * Definition for loading an existing plasmid
 *
 * @generated from message dictybase.stock.ExistingPlasmid
 */
export declare class ExistingPlasmid extends Message<ExistingPlasmid> {
  /**
   * @generated from field: dictybase.stock.ExistingPlasmid.Data data = 1;
   */
  data?: ExistingPlasmid_Data;

  constructor(data?: PartialMessage<ExistingPlasmid>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.ExistingPlasmid";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExistingPlasmid;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExistingPlasmid;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExistingPlasmid;

  static equals(a: ExistingPlasmid | PlainMessage<ExistingPlasmid> | undefined, b: ExistingPlasmid | PlainMessage<ExistingPlasmid> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.ExistingPlasmid.Data
 */
export declare class ExistingPlasmid_Data extends Message<ExistingPlasmid_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Existing plasmid ID
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.ExistingPlasmidAttributes attributes = 3;
   */
  attributes?: ExistingPlasmidAttributes;

  constructor(data?: PartialMessage<ExistingPlasmid_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.ExistingPlasmid.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExistingPlasmid_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExistingPlasmid_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExistingPlasmid_Data;

  static equals(a: ExistingPlasmid_Data | PlainMessage<ExistingPlasmid_Data> | undefined, b: ExistingPlasmid_Data | PlainMessage<ExistingPlasmid_Data> | undefined): boolean;
}

/**
 * Defines attributes for loading an existing strain
 *
 * @generated from message dictybase.stock.ExistingStrainAttributes
 */
export declare class ExistingStrainAttributes extends Message<ExistingStrainAttributes> {
  /**
   * Timestamp for creation
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * Timestamp for update
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * User who created stock entry
   *
   * @generated from field: string created_by = 3;
   */
  createdBy: string;

  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 4;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 5;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 6;
   */
  editableSummary: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 7;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 8;
   */
  dbxrefs: string[];

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 9;
   */
  depositor: string;

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 10;
   */
  publications: string[];

  /**
   * Descriptor for the strain, a quick overview of its key genetic modifications
   *
   * @generated from field: string label = 11;
   */
  label: string;

  /**
   * Species of the strain
   *
   * @generated from field: string species = 12;
   */
  species: string;

  /**
   * Related plasmid for the strain
   *
   * @generated from field: string plasmid = 13;
   */
  plasmid: string;

  /**
   * Parent of the strain
   *
   * @generated from field: string parent = 14;
   */
  parent: string;

  /**
   * List of names for the strain
   *
   * @generated from field: repeated string names = 15;
   */
  names: string[];

  /**
   * dictybase specific strain property that will
   * map to dicty_strain_property ontology
   *
   * @generated from field: string dicty_strain_property = 16;
   */
  dictyStrainProperty: string;

  constructor(data?: PartialMessage<ExistingStrainAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.ExistingStrainAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExistingStrainAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExistingStrainAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExistingStrainAttributes;

  static equals(a: ExistingStrainAttributes | PlainMessage<ExistingStrainAttributes> | undefined, b: ExistingStrainAttributes | PlainMessage<ExistingStrainAttributes> | undefined): boolean;
}

/**
 * Defines attributes for loading an existing plasmid
 *
 * @generated from message dictybase.stock.ExistingPlasmidAttributes
 */
export declare class ExistingPlasmidAttributes extends Message<ExistingPlasmidAttributes> {
  /**
   * Timestamp for creation
   *
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * Timestamp for update
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 2;
   */
  updatedAt?: Timestamp;

  /**
   * User who created stock entry
   *
   * @generated from field: string created_by = 3;
   */
  createdBy: string;

  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 4;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 5;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 6;
   */
  editableSummary: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 7;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 8;
   */
  dbxrefs: string[];

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 9;
   */
  depositor: string;

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 10;
   */
  publications: string[];

  /**
   * Image map for the plasmid
   *
   * @generated from field: string image_map = 11;
   */
  imageMap: string;

  /**
   * Sequence for the plasmid
   *
   * @generated from field: string sequence = 12;
   */
  sequence: string;

  /**
   * Unambiguous name for the plasmid
   *
   * @generated from field: string name = 13;
   */
  name: string;

  /**
   * dictybase specific plasmid property that will
   * map to dicty_plasmid_keyword ontology
   *
   * @generated from field: string dicty_plasmid_property = 14;
   */
  dictyPlasmidProperty: string;

  constructor(data?: PartialMessage<ExistingPlasmidAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.ExistingPlasmidAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExistingPlasmidAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExistingPlasmidAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExistingPlasmidAttributes;

  static equals(a: ExistingPlasmidAttributes | PlainMessage<ExistingPlasmidAttributes> | undefined, b: ExistingPlasmidAttributes | PlainMessage<ExistingPlasmidAttributes> | undefined): boolean;
}

/**
 * Definition for creating a new strain
 *
 * @generated from message dictybase.stock.StrainUpdate
 */
export declare class StrainUpdate extends Message<StrainUpdate> {
  /**
   * @generated from field: dictybase.stock.StrainUpdate.Data data = 1;
   */
  data?: StrainUpdate_Data;

  constructor(data?: PartialMessage<StrainUpdate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainUpdate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainUpdate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainUpdate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainUpdate;

  static equals(a: StrainUpdate | PlainMessage<StrainUpdate> | undefined, b: StrainUpdate | PlainMessage<StrainUpdate> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.StrainUpdate.Data
 */
export declare class StrainUpdate_Data extends Message<StrainUpdate_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Unique ID for strain
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.StrainUpdateAttributes attributes = 3;
   */
  attributes?: StrainUpdateAttributes;

  constructor(data?: PartialMessage<StrainUpdate_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainUpdate.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainUpdate_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainUpdate_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainUpdate_Data;

  static equals(a: StrainUpdate_Data | PlainMessage<StrainUpdate_Data> | undefined, b: StrainUpdate_Data | PlainMessage<StrainUpdate_Data> | undefined): boolean;
}

/**
 * Definition for creating a new plasmid
 *
 * @generated from message dictybase.stock.PlasmidUpdate
 */
export declare class PlasmidUpdate extends Message<PlasmidUpdate> {
  /**
   * @generated from field: dictybase.stock.PlasmidUpdate.Data data = 1;
   */
  data?: PlasmidUpdate_Data;

  constructor(data?: PartialMessage<PlasmidUpdate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.PlasmidUpdate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlasmidUpdate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlasmidUpdate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlasmidUpdate;

  static equals(a: PlasmidUpdate | PlainMessage<PlasmidUpdate> | undefined, b: PlasmidUpdate | PlainMessage<PlasmidUpdate> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.PlasmidUpdate.Data
 */
export declare class PlasmidUpdate_Data extends Message<PlasmidUpdate_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Unique ID for plasmid
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.PlasmidUpdateAttributes attributes = 3;
   */
  attributes?: PlasmidUpdateAttributes;

  constructor(data?: PartialMessage<PlasmidUpdate_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.PlasmidUpdate.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlasmidUpdate_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlasmidUpdate_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlasmidUpdate_Data;

  static equals(a: PlasmidUpdate_Data | PlainMessage<PlasmidUpdate_Data> | undefined, b: PlasmidUpdate_Data | PlainMessage<PlasmidUpdate_Data> | undefined): boolean;
}

/**
 * Defines attributes for updating a strain
 *
 * @generated from message dictybase.stock.StrainUpdateAttributes
 */
export declare class StrainUpdateAttributes extends Message<StrainUpdateAttributes> {
  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 1;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 2;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 3;
   */
  editableSummary: string;

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 4;
   */
  depositor: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 5;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 6;
   */
  dbxrefs: string[];

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 7;
   */
  publications: string[];

  /**
   * Descriptor for the strain, a quick overview of its key genetic modifications
   *
   * @generated from field: string label = 8;
   */
  label: string;

  /**
   * Species of the strain
   *
   * @generated from field: string species = 9;
   */
  species: string;

  /**
   * Related plasmid for the strain
   *
   * @generated from field: string plasmid = 10;
   */
  plasmid: string;

  /**
   * Parent of the strain
   *
   * @generated from field: string parent = 11;
   */
  parent: string;

  /**
   * List of names for the strain
   *
   * @generated from field: repeated string names = 12;
   */
  names: string[];

  /**
   * dictybase specific strain property that will
   * map to dicty_strain_property ontology
   *
   * @generated from field: string dicty_strain_property = 13;
   */
  dictyStrainProperty: string;

  constructor(data?: PartialMessage<StrainUpdateAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainUpdateAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainUpdateAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainUpdateAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainUpdateAttributes;

  static equals(a: StrainUpdateAttributes | PlainMessage<StrainUpdateAttributes> | undefined, b: StrainUpdateAttributes | PlainMessage<StrainUpdateAttributes> | undefined): boolean;
}

/**
 * Defines attributes for updating a plasmid
 *
 * @generated from message dictybase.stock.PlasmidUpdateAttributes
 */
export declare class PlasmidUpdateAttributes extends Message<PlasmidUpdateAttributes> {
  /**
   * User who updated stock entry
   *
   * @generated from field: string updated_by = 1;
   */
  updatedBy: string;

  /**
   * Summary of the stock
   *
   * @generated from field: string summary = 2;
   */
  summary: string;

  /**
   * Editable version of the stock summary (Slate JSON format)
   *
   * @generated from field: string editable_summary = 3;
   */
  editableSummary: string;

  /**
   * Depositor of the stock
   *
   * @generated from field: string depositor = 4;
   */
  depositor: string;

  /**
   * List of associated genes
   *
   * @generated from field: repeated string genes = 5;
   */
  genes: string[];

  /**
   * List of database cross references
   *
   * @generated from field: repeated string dbxrefs = 6;
   */
  dbxrefs: string[];

  /**
   * List of related publications
   *
   * @generated from field: repeated string publications = 7;
   */
  publications: string[];

  /**
   * Image map for the plasmid
   *
   * @generated from field: string image_map = 8;
   */
  imageMap: string;

  /**
   * Sequence for the plasmid
   *
   * @generated from field: string sequence = 9;
   */
  sequence: string;

  /**
   * Unambiguous name for the plasmid
   *
   * @generated from field: string name = 10;
   */
  name: string;

  /**
   * dictybase specific plasmid property that will
   * map to dicty_plasmid_keyword ontology
   *
   * @generated from field: string dicty_plasmid_property = 11;
   */
  dictyPlasmidProperty: string;

  constructor(data?: PartialMessage<PlasmidUpdateAttributes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.PlasmidUpdateAttributes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlasmidUpdateAttributes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlasmidUpdateAttributes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlasmidUpdateAttributes;

  static equals(a: PlasmidUpdateAttributes | PlainMessage<PlasmidUpdateAttributes> | undefined, b: PlasmidUpdateAttributes | PlainMessage<PlasmidUpdateAttributes> | undefined): boolean;
}

/**
 * List of strains without any metadata for pagination
 *
 * @generated from message dictybase.stock.StrainList
 */
export declare class StrainList extends Message<StrainList> {
  /**
   * @generated from field: repeated dictybase.stock.StrainList.Data data = 1;
   */
  data: StrainList_Data[];

  constructor(data?: PartialMessage<StrainList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainList;

  static equals(a: StrainList | PlainMessage<StrainList> | undefined, b: StrainList | PlainMessage<StrainList> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.StrainList.Data
 */
export declare class StrainList_Data extends Message<StrainList_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Unique identifier for the stock
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.StrainAttributes attributes = 3;
   */
  attributes?: StrainAttributes;

  constructor(data?: PartialMessage<StrainList_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainList.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainList_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainList_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainList_Data;

  static equals(a: StrainList_Data | PlainMessage<StrainList_Data> | undefined, b: StrainList_Data | PlainMessage<StrainList_Data> | undefined): boolean;
}

/**
 * List of strains
 *
 * @generated from message dictybase.stock.StrainCollection
 */
export declare class StrainCollection extends Message<StrainCollection> {
  /**
   * @generated from field: repeated dictybase.stock.StrainCollection.Data data = 1;
   */
  data: StrainCollection_Data[];

  /**
   * @generated from field: dictybase.stock.Meta meta = 2;
   */
  meta?: Meta;

  constructor(data?: PartialMessage<StrainCollection>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainCollection";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainCollection;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainCollection;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainCollection;

  static equals(a: StrainCollection | PlainMessage<StrainCollection> | undefined, b: StrainCollection | PlainMessage<StrainCollection> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.StrainCollection.Data
 */
export declare class StrainCollection_Data extends Message<StrainCollection_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Unique identifier for the stock
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.StrainAttributes attributes = 3;
   */
  attributes?: StrainAttributes;

  constructor(data?: PartialMessage<StrainCollection_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StrainCollection.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrainCollection_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrainCollection_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrainCollection_Data;

  static equals(a: StrainCollection_Data | PlainMessage<StrainCollection_Data> | undefined, b: StrainCollection_Data | PlainMessage<StrainCollection_Data> | undefined): boolean;
}

/**
 * List of plasmids
 *
 * @generated from message dictybase.stock.PlasmidCollection
 */
export declare class PlasmidCollection extends Message<PlasmidCollection> {
  /**
   * @generated from field: repeated dictybase.stock.PlasmidCollection.Data data = 1;
   */
  data: PlasmidCollection_Data[];

  /**
   * @generated from field: dictybase.stock.Meta meta = 2;
   */
  meta?: Meta;

  constructor(data?: PartialMessage<PlasmidCollection>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.PlasmidCollection";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlasmidCollection;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlasmidCollection;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlasmidCollection;

  static equals(a: PlasmidCollection | PlainMessage<PlasmidCollection> | undefined, b: PlasmidCollection | PlainMessage<PlasmidCollection> | undefined): boolean;
}

/**
 * @generated from message dictybase.stock.PlasmidCollection.Data
 */
export declare class PlasmidCollection_Data extends Message<PlasmidCollection_Data> {
  /**
   * Resource name
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Unique identifier for the stock
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * @generated from field: dictybase.stock.PlasmidAttributes attributes = 3;
   */
  attributes?: PlasmidAttributes;

  constructor(data?: PartialMessage<PlasmidCollection_Data>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.PlasmidCollection.Data";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlasmidCollection_Data;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlasmidCollection_Data;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlasmidCollection_Data;

  static equals(a: PlasmidCollection_Data | PlainMessage<PlasmidCollection_Data> | undefined, b: PlasmidCollection_Data | PlainMessage<PlasmidCollection_Data> | undefined): boolean;
}

/**
 * StockParameters defines fields for manipulating output of Stock collection
 *
 * @generated from message dictybase.stock.StockParameters
 */
export declare class StockParameters extends Message<StockParameters> {
  /**
   * A unique pointer to the next set of result in the list (default is 0)
   *
   * @generated from field: int64 cursor = 1;
   */
  cursor: bigint;

  /**
   * Maximum number of records that can be fetch per request (default is 10)
   *
   * @generated from field: int64 limit = 2;
   */
  limit: bigint;

  /**
   * The `filter` field restricts the data return by the collection. To use
   * it, supply one or multiple allowed fields to filter followed
   * by a filter expression. It uses the following syntax...
   *        field_name operator expression
   *
   * The following fields of `StockAttributes` definition are allowed to
   * be used for filtering
   *   * depositor          - Depositor of the stock (string)
   *   * parent             - Parental strain (string) (currently not implemented)
   *   * plasmid            - Related plasmid for the strain (string)
   *   * species            - The species of the strain (string)
   *   * summary            - Summary of the stock (string)
   *   * name               - Name used for strain (string), searches in the "names" attribute
   *   * descriptor         - Descriptor for the strain (string), searches in the "label" attribute
   *   * plasmid_name       - Name used for plasmid (string)
   *   * created_at         - Date the stock was created (number), can be in the
   *                          following formats:
   *                          YYYY-MM-DD, YYYY-MM, YYYY
   *   * updated_at         - Date the stock was updated (number), can be in the
   *                          following formats:
   *                          YYYY-MM-DD, YYYY-MM, YYYY
   *
   * field_name - Any one of the allowed field_name of the `StockAttributes` definition.
   * operator - Defines the type of filter match to use. It could be any of
   * the following four and all of them should be URL-encoded for http request.
   *
   *        Operators for strings
   *              =~   Contains substring
   *              !~   Not contains substring
   *              ===  Equals
   *              !=   Not equals
   *
   *        Operators for number
   *              ==  Equals
   *              >   Greater than
   *              <   Less than
   *              <=  Less than equal to
   *              >=  Greater than equal to
   *
   *        Operators for dates
   *              $==  Equals
   *              $>   Greater than
   *              $<   Less than
   *              $<=  Less than equal to
   *              $>=  Greater than equal to
   *
   *        Operators for items in arrays
   *              @=~   Contains substring
   *              @!~   Not contains substring (not implemented yet)
   *              @==   Equals
   *              @!=   Not equals
   *
   * expression - The value that will be included or excluded from the
   * result. URL-reserved characters must be URL-encoded for http request.
   *
   *           filter: "created_at$>=2018-12-01"
   *           filter: "depositor===Costanza"
   *
   * Filter can be combined using OR or AND boolean logic.
   *   * The OR is represented using a comma(,).
   *   * The AND is represented using a semi-colon(;).
   *   * AND and OR operators can be combined and AND takes precedence over OR.
   *
   *           filter: "depositor===Benes;created_at$>=2018-12-01"
   *
   *
   * The sort field allow to sort the data return by the collection based on
   * fields of `StockAttributes. To use it, supply a comma separated one
   * or more allowed field from the definition of `StockAttributes`.
   *
   * @generated from field: string filter = 3;
   */
  filter: string;

  constructor(data?: PartialMessage<StockParameters>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.StockParameters";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StockParameters;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StockParameters;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StockParameters;

  static equals(a: StockParameters | PlainMessage<StockParameters> | undefined, b: StockParameters | PlainMessage<StockParameters> | undefined): boolean;
}

/**
 * Metadata definition for traversing the collection
 *
 * @generated from message dictybase.stock.Meta
 */
export declare class Meta extends Message<Meta> {
  /**
   * A unique pointer to the next set of result in the collection. Set the
   * cursor value parameter to the value of next_cursor to retrieve the next
   * set of collection using the same method
   *
   * @generated from field: int64 next_cursor = 1;
   */
  nextCursor: bigint;

  /**
   * Maximum number of records that can be fetch per request
   *
   * @generated from field: int64 limit = 2;
   */
  limit: bigint;

  /**
   * Total number of records in the collection.
   *
   * @generated from field: int64 total = 3;
   */
  total: bigint;

  constructor(data?: PartialMessage<Meta>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "dictybase.stock.Meta";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Meta;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Meta;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Meta;

  static equals(a: Meta | PlainMessage<Meta> | undefined, b: Meta | PlainMessage<Meta> | undefined): boolean;
}

